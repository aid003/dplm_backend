import { BaseScanner, ScanResult, ScanOptions } from './base-scanner';
import type { VulnerabilityPattern } from '../patterns/base-pattern';
import { promises as fsp } from 'fs';
import { join } from 'path';

export class GoScanner extends BaseScanner {
  readonly supportedLanguages = ['go'];

  scanFile(
    filePath: string,
    content: string,
    patterns: VulnerabilityPattern[],
  ): ScanResult {
    const startTime = Date.now();
    const vulnerabilities: any[] = [];

    // Фильтруем паттерны для Go
    const relevantPatterns = patterns.filter((pattern) =>
      pattern.languages.includes('go'),
    );

    // Сканируем каждый паттерн
    for (const pattern of relevantPatterns) {
      try {
        const matches = pattern.detect(content, filePath);
        vulnerabilities.push(...matches);
      } catch (error) {
        this.logger.warn(
          `Ошибка при сканировании паттерна ${pattern.id} в файле ${filePath}:`,
          error,
        );
      }
    }

    const scanTime = Date.now() - startTime;
    return this.createScanResult(
      filePath,
      'go',
      vulnerabilities as any[],
      scanTime,
    );
  }

  protected async findSourceFiles(
    projectPath: string,
    options: ScanOptions,
  ): Promise<string[]> {
    const files: string[] = [];
    const extensions = ['.go'];

    await this.walkDirectory(projectPath, files, extensions, options);
    return files;
  }

  private async walkDirectory(
    dir: string,
    files: string[],
    extensions: string[],
    options: ScanOptions,
  ): Promise<void> {
    try {
      const entries = await fsp.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = join(dir, entry.name);

        if (entry.isDirectory()) {
          // Пропускаем скрытые директории и vendor
          if (
            !entry.name.startsWith('.') &&
            entry.name !== 'vendor' &&
            entry.name !== 'node_modules' &&
            !this.isIgnoredDirectory(entry.name)
          ) {
            await this.walkDirectory(fullPath, files, extensions, options);
          }
        } else if (entry.isFile()) {
          const ext = entry.name.split('.').pop()?.toLowerCase();
          if (ext && extensions.includes(`.${ext}`)) {
            files.push(fullPath);
          }
        }
      }
    } catch (error) {
      this.logger.warn(`Не удалось прочитать директорию ${dir}:`, error);
    }
  }

  private isIgnoredDirectory(dirName: string): boolean {
    const ignoredDirs = [
      'vendor',
      'node_modules',
      '.git',
      '.svn',
      '.hg',
      'testdata',
      'examples',
      'docs',
      'documentation',
      'tmp',
      'temp',
      'logs',
      'cache',
      '.cache',
      'build',
      'dist',
      'out',
      'bin',
      'obj',
      '.vscode',
      '.idea',
      '.vs',
    ];

    return ignoredDirs.includes(dirName.toLowerCase());
  }
}

import { BaseScanner, ScanResult, ScanOptions } from './base-scanner';
import { VulnerabilityPattern } from '../patterns';
import { promises as fsp } from 'node:fs';

export class TypeScriptScanner extends BaseScanner {
  readonly supportedLanguages = ['typescript', 'javascript'];

  async scanFile(filePath: string, content: string, patterns: VulnerabilityPattern[]): Promise<ScanResult> {
    const startTime = Date.now();
    const language = this.detectLanguage(filePath);
    const relevantPatterns = this.filterPatternsByLanguage(patterns, language);
    
    const vulnerabilities: any[] = [];

    // Сканируем каждый паттерн
    for (const pattern of relevantPatterns) {
      try {
        const matches = pattern.detect(content, filePath);
        vulnerabilities.push(...matches);
      } catch (error) {
        console.warn(`Ошибка при сканировании паттерна ${pattern.id} в файле ${filePath}:`, error);
      }
    }

    const scanTime = Date.now() - startTime;
    return this.createScanResult(filePath, language, vulnerabilities, scanTime);
  }

  async scanProject(projectPath: string, patterns: VulnerabilityPattern[], options: ScanOptions = {}): Promise<ScanResult[]> {
    const files = await this.findSourceFiles(projectPath, options);
    const results: ScanResult[] = [];

    for (const file of files) {
      try {
        const content = await fsp.readFile(file, 'utf-8');
        const result = await this.scanFile(file, content, patterns);
        results.push(result);
      } catch (error) {
        console.warn(`Не удалось сканировать файл ${file}:`, error);
      }
    }

    return results;
  }

  private async findSourceFiles(projectPath: string, options: ScanOptions): Promise<string[]> {
    const files: string[] = [];
    const extensions = ['.ts', '.tsx', '.js', '.jsx'];
    
    await this.walkDirectory(projectPath, files, extensions, options);
    return files;
  }

  private async walkDirectory(
    dir: string, 
    files: string[], 
    extensions: string[], 
    options: ScanOptions
  ): Promise<void> {
    try {
      const entries = await fsp.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = `${dir}/${entry.name}`;
        
        if (entry.isDirectory()) {
          // Пропускаем служебные директории
          if (!this.isIgnoredDirectory(entry.name)) {
            await this.walkDirectory(fullPath, files, extensions, options);
          }
        } else if (entry.isFile()) {
          const ext = this.getFileExtension(entry.name);
          if (extensions.includes(ext) && !this.shouldSkipFile(fullPath, options)) {
            files.push(fullPath);
          }
        }
      }
    } catch (error) {
      console.warn(`Не удалось прочитать директорию ${dir}:`, error);
    }
  }

  private isIgnoredDirectory(dirName: string): boolean {
    const ignoredDirs = [
      'node_modules',
      '.git',
      'dist',
      'build',
      '.next',
      '.turbo',
      'coverage',
      '.nyc_output',
      'tmp',
      'temp',
    ];
    
    return ignoredDirs.includes(dirName) || dirName.startsWith('.');
  }
}

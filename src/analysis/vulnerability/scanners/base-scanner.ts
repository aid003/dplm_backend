import { VulnerabilityPattern, VulnerabilityMatch } from '../patterns';

export interface ScanResult {
  filePath: string;
  language: string;
  vulnerabilities: VulnerabilityMatch[];
  scanTime: number;
}

export interface ScanOptions {
  includeTests?: boolean;
  maxFileSize?: number; // в байтах
  excludePatterns?: string[];
}

export abstract class BaseScanner {
  abstract readonly supportedLanguages: string[];

  abstract scanFile(filePath: string, content: string, patterns: VulnerabilityPattern[]): Promise<ScanResult>;

  protected detectLanguage(filePath: string): string {
    const ext = this.getFileExtension(filePath).toLowerCase();
    
    switch (ext) {
      case '.ts':
      case '.tsx':
        return 'typescript';
      case '.js':
      case '.jsx':
        return 'javascript';
      case '.py':
        return 'python';
      case '.java':
        return 'java';
      case '.go':
        return 'go';
      default:
        return 'unknown';
    }
  }

  protected getFileExtension(filePath: string): string {
    const lastDot = filePath.lastIndexOf('.');
    return lastDot === -1 ? '' : filePath.substring(lastDot);
  }

  protected shouldSkipFile(filePath: string, options: ScanOptions): boolean {
    // Пропускаем тестовые файлы если не включены
    if (!options.includeTests && this.isTestFile(filePath)) {
      return true;
    }

    // Пропускаем файлы по паттернам исключения
    if (options.excludePatterns) {
      for (const pattern of options.excludePatterns) {
        if (filePath.includes(pattern)) {
          return true;
        }
      }
    }

    return false;
  }

  protected isTestFile(filePath: string): boolean {
    const testPatterns = [
      '/test/',
      '/tests/',
      '/__tests__/',
      '/spec/',
      '/specs/',
      '.test.',
      '.spec.',
      '.e2e.',
      '.integration.',
    ];

    return testPatterns.some(pattern => filePath.includes(pattern));
  }

  protected filterPatternsByLanguage(patterns: VulnerabilityPattern[], language: string): VulnerabilityPattern[] {
    return patterns.filter(pattern => 
      pattern.languages.includes(language.toLowerCase())
    );
  }

  protected createScanResult(
    filePath: string,
    language: string,
    vulnerabilities: VulnerabilityMatch[],
    scanTime: number
  ): ScanResult {
    return {
      filePath,
      language,
      vulnerabilities,
      scanTime,
    };
  }
}

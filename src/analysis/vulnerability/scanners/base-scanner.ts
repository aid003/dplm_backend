import { VulnerabilityPattern, VulnerabilityMatch } from '../patterns';
import { Logger } from '@nestjs/common';
import { getLogLevel } from '../../utils/environment.util';

export interface ScanResult {
  filePath: string;
  language: string;
  vulnerabilities: VulnerabilityMatch[];
  scanTime: number;
}

export interface ScanOptions {
  includeTests?: boolean;
  maxFileSize?: number; // в байтах
  excludePatterns?: string[];
}

export abstract class BaseScanner {
  protected readonly logger = new Logger(this.constructor.name);
  abstract readonly supportedLanguages: string[];

  abstract scanFile(
    filePath: string,
    content: string,
    patterns: VulnerabilityPattern[],
  ): ScanResult;

  async scanProject(
    projectPath: string,
    patterns: VulnerabilityPattern[],
    options: ScanOptions,
  ): Promise<ScanResult[]> {
    const logLevel = getLogLevel();
    const startTime = Date.now();

    this.logger.log(`Начинаем сканирование проекта ${projectPath} сканером ${this.constructor.name}`);

    if (logLevel === 'detailed') {
      this.logger.debug('Параметры сканирования проекта:', {
        projectPath,
        patternsCount: patterns.length,
        options,
        supportedLanguages: this.supportedLanguages,
      });
    }

    const files = await this.findSourceFiles(projectPath, options);
    this.logger.log(`Найдено ${files.length} файлов для сканирования`);

    const results: ScanResult[] = [];
    let processedFiles = 0;
    let totalVulnerabilities = 0;

    for (const filePath of files) {
      try {
        const fileStartTime = Date.now();
        this.logger.log(`Сканируем файл ${filePath}`);

        const content = await this.readFileContent(filePath);
        const result = this.scanFile(filePath, content, patterns);
        
        const fileDuration = Date.now() - fileStartTime;
        this.logger.log(`Файл ${filePath} отсканирован за ${fileDuration}ms: найдено ${result.vulnerabilities.length} уязвимостей`);

        if (logLevel === 'detailed' && result.vulnerabilities.length > 0) {
          this.logger.debug(`Уязвимости в файле ${filePath}:`, {
            count: result.vulnerabilities.length,
            vulnerabilities: result.vulnerabilities.map(v => ({
              lineStart: v.lineStart,
              lineEnd: v.lineEnd,
              message: v.message.substring(0, 100) + '...',
            })),
          });
        }

        results.push(result);
        processedFiles++;
        totalVulnerabilities += result.vulnerabilities.length;

      } catch (error) {
        this.logger.warn(`Ошибка при сканировании файла ${filePath}:`, error);
      }
    }

    const totalDuration = Date.now() - startTime;
    this.logger.log(`Сканирование проекта завершено за ${totalDuration}ms: обработано ${processedFiles} файлов, найдено ${totalVulnerabilities} уязвимостей`);

    if (logLevel === 'detailed') {
      this.logger.debug('Статистика сканирования:', {
        projectPath,
        processedFiles,
        totalVulnerabilities,
        totalDuration,
        vulnerabilitiesByFile: results.map(r => ({
          filePath: r.filePath,
          count: r.vulnerabilities.length,
          scanTime: r.scanTime,
        })),
      });
    }

    return results;
  }

  protected async findSourceFiles(
    projectPath: string,
    options: ScanOptions,
  ): Promise<string[]> {
    // Базовая реализация - должна быть переопределена в наследниках
    return [];
  }

  protected async readFileContent(filePath: string): Promise<string> {
    const { promises: fsp } = await import('node:fs');
    return fsp.readFile(filePath, 'utf-8');
  }

  protected detectLanguage(filePath: string): string {
    const ext = this.getFileExtension(filePath).toLowerCase();

    switch (ext) {
      case '.ts':
      case '.tsx':
        return 'typescript';
      case '.js':
      case '.jsx':
        return 'javascript';
      case '.py':
        return 'python';
      case '.java':
        return 'java';
      case '.go':
        return 'go';
      default:
        return 'unknown';
    }
  }

  protected getFileExtension(filePath: string): string {
    const lastDot = filePath.lastIndexOf('.');
    return lastDot === -1 ? '' : filePath.substring(lastDot);
  }

  protected shouldSkipFile(filePath: string, options: ScanOptions): boolean {
    // Пропускаем тестовые файлы если не включены
    if (!options.includeTests && this.isTestFile(filePath)) {
      return true;
    }

    // Пропускаем файлы по паттернам исключения
    if (options.excludePatterns) {
      for (const pattern of options.excludePatterns) {
        if (filePath.includes(pattern)) {
          return true;
        }
      }
    }

    return false;
  }

  protected isTestFile(filePath: string): boolean {
    const testPatterns = [
      '/test/',
      '/tests/',
      '/__tests__/',
      '/spec/',
      '/specs/',
      '.test.',
      '.spec.',
      '.e2e.',
      '.integration.',
    ];

    return testPatterns.some((pattern) => filePath.includes(pattern));
  }

  protected filterPatternsByLanguage(
    patterns: VulnerabilityPattern[],
    language: string,
  ): VulnerabilityPattern[] {
    return patterns.filter((pattern) =>
      pattern.languages.includes(language.toLowerCase()),
    );
  }

  protected createScanResult(
    filePath: string,
    language: string,
    vulnerabilities: VulnerabilityMatch[],
    scanTime: number,
  ): ScanResult {
    return {
      filePath,
      language,
      vulnerabilities,
      scanTime,
    };
  }
}

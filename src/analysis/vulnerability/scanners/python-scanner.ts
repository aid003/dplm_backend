import { BaseScanner, ScanResult, ScanOptions } from './base-scanner';
import { VulnerabilityPattern, VulnerabilityMatch } from '../patterns';
import { promises as fsp } from 'node:fs';

export class PythonScanner extends BaseScanner {
  readonly supportedLanguages = ['python'];

  scanFile(
    filePath: string,
    content: string,
    patterns: VulnerabilityPattern[],
  ): ScanResult {
    const startTime = Date.now();
    const language = this.detectLanguage(filePath);
    const relevantPatterns = this.filterPatternsByLanguage(patterns, language);

    const vulnerabilities: unknown[] = [];

    // Сканируем каждый паттерн
    for (const pattern of relevantPatterns) {
      try {
        const matches = pattern.detect(content, filePath);
        vulnerabilities.push(...matches);
      } catch (error) {
        this.logger.warn(
          `Ошибка при сканировании паттерна ${pattern.id} в файле ${filePath}:`,
          error,
        );
      }
    }

    const scanTime = Date.now() - startTime;
    return this.createScanResult(
      filePath,
      language,
      vulnerabilities as VulnerabilityMatch[],
      scanTime,
    );
  }

  protected async findSourceFiles(
    projectPath: string,
    options: ScanOptions,
  ): Promise<string[]> {
    const files: string[] = [];
    const extensions = ['.py'];

    await this.walkDirectory(projectPath, files, extensions, options);
    return files;
  }

  private async walkDirectory(
    dir: string,
    files: string[],
    extensions: string[],
    options: ScanOptions,
  ): Promise<void> {
    try {
      const entries = await fsp.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = `${dir}/${entry.name}`;

        if (entry.isDirectory()) {
          // Пропускаем служебные директории
          if (!this.isIgnoredDirectory(entry.name)) {
            await this.walkDirectory(fullPath, files, extensions, options);
          }
        } else if (entry.isFile()) {
          const ext = this.getFileExtension(entry.name);
          if (
            extensions.includes(ext) &&
            !this.shouldSkipFile(fullPath, options)
          ) {
            files.push(fullPath);
          }
        }
      }
    } catch (error) {
      this.logger.warn(`Не удалось прочитать директорию ${dir}:`, error);
    }
  }

  private isIgnoredDirectory(dirName: string): boolean {
    const ignoredDirs = [
      '__pycache__',
      '.git',
      'dist',
      'build',
      '.pytest_cache',
      '.coverage',
      'venv',
      'env',
      '.venv',
      '.env',
      'node_modules',
      'tmp',
      'temp',
    ];

    return ignoredDirs.includes(dirName) || dirName.startsWith('.');
  }
}

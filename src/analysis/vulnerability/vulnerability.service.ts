import { Injectable, Logger } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { ProjectsService } from '../../projects/projects.service';
import { ALL_VULNERABILITY_PATTERNS, getPatternsByLanguage } from './patterns';
import { TypeScriptScanner } from './scanners/typescript-scanner';
import { PythonScanner } from './scanners/python-scanner';
import { ScanResult, ScanOptions } from './scanners/base-scanner';
import { VulnSeverity } from '../dto/analysis-response.dto';
import type { AnalysisReport, Vulnerability } from '../../../generated/prisma';

export interface VulnerabilityScanOptions extends ScanOptions {
  languages?: string[];
  severityThreshold?: VulnSeverity;
}

export interface VulnerabilityStats {
  total: number;
  bySeverity: Record<VulnSeverity, number>;
  byType: Record<string, number>;
  byFile: Record<string, number>;
}

@Injectable()
export class VulnerabilityService {
  private readonly logger = new Logger(VulnerabilityService.name);
  private readonly scanners = [
    new TypeScriptScanner(),
    new PythonScanner(),
  ];

  constructor(
    private readonly databaseService: DatabaseService,
    private readonly projectsService: ProjectsService,
  ) {}

  async scanProject(
    userId: string,
    projectId: string,
    options: VulnerabilityScanOptions = {}
  ): Promise<AnalysisReport> {
    const project = await this.projectsService.findByIdForUser(userId, projectId);
    
    // Создаем отчет о сканировании
    const report = await this.databaseService.analysisReport.create({
      data: {
        projectId,
        type: 'VULNERABILITY',
        status: 'PROCESSING',
        language: options.languages?.join(',') || 'all',
        result: {},
        progress: {
          currentStep: 'Starting vulnerability scan',
          percentage: 0,
          processedFiles: 0,
          totalFiles: 0,
        },
      },
    });

    try {
      // Запускаем сканирование в фоне
      this.performScan(report.id, project.extractedPath, options);
      
      return report;
    } catch (error) {
      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
      throw error;
    }
  }

  async scanFile(
    userId: string,
    projectId: string,
    filePath: string,
    options: VulnerabilityScanOptions = {}
  ): Promise<AnalysisReport> {
    const project = await this.projectsService.findByIdForUser(userId, projectId);
    
    const report = await this.databaseService.analysisReport.create({
      data: {
        projectId,
        type: 'VULNERABILITY',
        status: 'PROCESSING',
        filePath,
        language: this.detectLanguageFromPath(filePath),
        result: {},
        progress: {
          currentStep: 'Scanning file',
          percentage: 0,
          processedFiles: 0,
          totalFiles: 1,
        },
      },
    });

    try {
      const fullPath = `${project.extractedPath}/${filePath}`;
      const results = await this.scanSingleFile(fullPath, options);
      
      await this.saveVulnerabilities(report.id, results);
      
      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'COMPLETED',
          result: {
            vulnerabilitiesFound: results.vulnerabilities.length,
            scanTime: results.scanTime,
          },
          progress: {
            currentStep: 'Completed',
            percentage: 100,
            processedFiles: 1,
            totalFiles: 1,
          },
        },
      });

      return report;
    } catch (error) {
      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
      throw error;
    }
  }

  async getVulnerabilities(
    userId: string,
    projectId: string,
    filters: {
      severity?: VulnSeverity;
      filePath?: string;
      type?: string;
    } = {}
  ): Promise<{ vulnerabilities: Vulnerability[]; stats: VulnerabilityStats }> {
    await this.projectsService.findByIdForUser(userId, projectId);

    const where: any = {
      report: {
        projectId,
        type: 'VULNERABILITY',
      },
    };

    if (filters.severity) {
      where.severity = filters.severity;
    }

    if (filters.filePath) {
      where.filePath = { contains: filters.filePath };
    }

    if (filters.type) {
      where.type = filters.type;
    }

    const vulnerabilities = await this.databaseService.vulnerability.findMany({
      where,
      orderBy: [
        { severity: 'asc' },
        { createdAt: 'desc' },
      ],
    });

    const stats = this.calculateStats(vulnerabilities);

    return { vulnerabilities, stats };
  }

  private async performScan(
    reportId: string,
    projectPath: string,
    options: VulnerabilityScanOptions
  ): Promise<void> {
    try {
      const languages = options.languages || ['typescript', 'javascript', 'python'];
      const patterns = this.getPatternsForLanguages(languages);
      
      let allResults: ScanResult[] = [];
      let processedFiles = 0;
      let totalFiles = 0;

      // Подсчитываем общее количество файлов
      for (const scanner of this.scanners) {
        if (languages.some(lang => scanner.supportedLanguages.includes(lang))) {
          const files = await this.findSourceFiles(projectPath, scanner, options);
          totalFiles += files.length;
        }
      }

      await this.updateProgress(reportId, 'Scanning files', 0, processedFiles, totalFiles);

      // Сканируем каждый язык
      for (const scanner of this.scanners) {
        if (languages.some(lang => scanner.supportedLanguages.includes(lang))) {
          const results = await scanner.scanProject(projectPath, patterns, options);
          allResults.push(...results);
          processedFiles += results.length;

          const percentage = Math.round((processedFiles / totalFiles) * 100);
          await this.updateProgress(
            reportId,
            `Scanning ${scanner.constructor.name}`,
            percentage,
            processedFiles,
            totalFiles
          );
        }
      }

      // Сохраняем результаты
      await this.saveVulnerabilities(reportId, ...allResults);

      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          status: 'COMPLETED',
          result: {
            vulnerabilitiesFound: allResults.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
            filesScanned: allResults.length,
            totalScanTime: allResults.reduce((sum, r) => sum + r.scanTime, 0),
          },
          progress: {
            currentStep: 'Completed',
            percentage: 100,
            processedFiles,
            totalFiles,
          },
        },
      });

    } catch (error) {
      this.logger.error(`Ошибка при сканировании проекта ${reportId}:`, error);
      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
    }
  }

  private async scanSingleFile(filePath: string, options: VulnerabilityScanOptions): Promise<ScanResult> {
    const language = this.detectLanguageFromPath(filePath);
    const patterns = getPatternsByLanguage(language);
    
    const scanner = this.scanners.find(s => s.supportedLanguages.includes(language));
    if (!scanner) {
      throw new Error(`Нет сканера для языка ${language}`);
    }

    const { promises: fsp } = await import('node:fs');
    const content = await fsp.readFile(filePath, 'utf-8');
    
    return scanner.scanFile(filePath, content, patterns);
  }

  private async saveVulnerabilities(reportId: string, ...results: ScanResult[]): Promise<void> {
    const vulnerabilities: any[] = [];

    for (const result of results) {
      for (const vuln of result.vulnerabilities) {
        vulnerabilities.push({
          reportId,
          severity: this.mapSeverity(vuln.message),
          type: this.extractVulnType(vuln.message),
          title: this.generateTitle(vuln.message),
          description: vuln.message,
          filePath: result.filePath,
          lineStart: vuln.lineStart,
          lineEnd: vuln.lineEnd,
          codeSnippet: vuln.codeSnippet,
          recommendation: vuln.recommendation,
          cwe: this.extractCWE(vuln.message),
        });
      }
    }

    if (vulnerabilities.length > 0) {
      await this.databaseService.vulnerability.createMany({
        data: vulnerabilities,
      });
    }
  }

  private async updateProgress(
    reportId: string,
    currentStep: string,
    percentage: number,
    processedFiles: number,
    totalFiles: number
  ): Promise<void> {
    await this.databaseService.analysisReport.update({
      where: { id: reportId },
      data: {
        progress: {
          currentStep,
          percentage,
          processedFiles,
          totalFiles,
        },
      },
    });
  }

  private getPatternsForLanguages(languages: string[]) {
    const patterns = new Set();
    for (const lang of languages) {
      getPatternsByLanguage(lang).forEach(pattern => patterns.add(pattern));
    }
    return Array.from(patterns);
  }

  private async findSourceFiles(
    projectPath: string,
    scanner: any,
    options: VulnerabilityScanOptions
  ): Promise<string[]> {
    // Упрощенная реализация - в реальности нужно использовать методы сканера
    const { promises: fsp } = await import('node:fs');
    const files: string[] = [];
    
    const walk = async (dir: string) => {
      const entries = await fsp.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = `${dir}/${entry.name}`;
        if (entry.isDirectory() && !this.isIgnoredDirectory(entry.name)) {
          await walk(fullPath);
        } else if (entry.isFile() && scanner.supportedLanguages.includes(this.detectLanguageFromPath(fullPath))) {
          files.push(fullPath);
        }
      }
    };

    await walk(projectPath);
    return files;
  }

  private isIgnoredDirectory(dirName: string): boolean {
    const ignoredDirs = [
      'node_modules',
      '.git',
      'dist',
      'build',
      '.next',
      '.turbo',
      '__pycache__',
      '.pytest_cache',
      'venv',
      'env',
    ];
    return ignoredDirs.includes(dirName) || dirName.startsWith('.');
  }

  private detectLanguageFromPath(filePath: string): string {
    const ext = filePath.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'ts':
      case 'tsx':
        return 'typescript';
      case 'js':
      case 'jsx':
        return 'javascript';
      case 'py':
        return 'python';
      case 'java':
        return 'java';
      case 'go':
        return 'go';
      default:
        return 'unknown';
    }
  }

  private mapSeverity(message: string): VulnSeverity {
    if (message.includes('CRITICAL') || message.includes('Critical')) return 'CRITICAL';
    if (message.includes('HIGH') || message.includes('High')) return 'HIGH';
    if (message.includes('MEDIUM') || message.includes('Medium')) return 'MEDIUM';
    if (message.includes('LOW') || message.includes('Low')) return 'LOW';
    return 'INFO';
  }

  private extractVulnType(message: string): string {
    if (message.includes('SQL')) return 'SQL_INJECTION';
    if (message.includes('XSS')) return 'XSS';
    if (message.includes('Path')) return 'PATH_TRAVERSAL';
    if (message.includes('secret') || message.includes('password')) return 'HARDCODED_SECRETS';
    if (message.includes('crypto') || message.includes('MD5') || message.includes('SHA-1')) return 'INSECURE_CRYPTO';
    return 'UNKNOWN';
  }

  private generateTitle(message: string): string {
    return message.split('.')[0] || 'Security vulnerability detected';
  }

  private extractCWE(message: string): string | undefined {
    const cweMatch = message.match(/CWE-\d+/);
    return cweMatch ? cweMatch[0] : undefined;
  }

  private calculateStats(vulnerabilities: Vulnerability[]): VulnerabilityStats {
    const stats: VulnerabilityStats = {
      total: vulnerabilities.length,
      bySeverity: {
        CRITICAL: 0,
        HIGH: 0,
        MEDIUM: 0,
        LOW: 0,
        INFO: 0,
      },
      byType: {},
      byFile: {},
    };

    for (const vuln of vulnerabilities) {
      stats.bySeverity[vuln.severity]++;
      stats.byType[vuln.type] = (stats.byType[vuln.type] || 0) + 1;
      stats.byFile[vuln.filePath] = (stats.byFile[vuln.filePath] || 0) + 1;
    }

    return stats;
  }
}

import { Injectable, Logger } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { ProjectsService } from '../../projects/projects.service';
import { getPatternsByLanguage, type VulnerabilityPattern } from './patterns';
import { TypeScriptScanner } from './scanners/typescript-scanner';
import { PythonScanner } from './scanners/python-scanner';
import { GoScanner } from './scanners/go-scanner';
import { ScanResult, ScanOptions, BaseScanner } from './scanners/base-scanner';
import { VulnSeverity } from '../dto/analysis-response.dto';
import type {
  AnalysisReport,
  Vulnerability,
  Prisma,
} from '../../../generated/prisma';
import {
  isDevelopment,
  getLogLevel,
  AnalysisCancellationError,
} from '../utils/environment.util';

export interface VulnerabilityScanOptions extends ScanOptions {
  languages?: string[];
  severityThreshold?: VulnSeverity;
}

export interface VulnerabilityStats {
  total: number;
  bySeverity: Record<VulnSeverity, number>;
  byType: Record<string, number>;
  byFile: Record<string, number>;
}

@Injectable()
export class VulnerabilityService {
  private readonly logger = new Logger(VulnerabilityService.name);
  private readonly scanners = [new TypeScriptScanner(), new PythonScanner(), new GoScanner()];

  constructor(
    private readonly databaseService: DatabaseService,
    private readonly projectsService: ProjectsService,
  ) {}

  async scanProject(
    userId: string,
    projectId: string,
    options: VulnerabilityScanOptions = {},
  ): Promise<AnalysisReport> {
    const logLevel = getLogLevel();
    const startTime = Date.now();

    this.logger.log(
      `Начинаем сканирование уязвимостей проекта ${projectId} для пользователя ${userId}`,
    );

    if (logLevel === 'detailed') {
      this.logger.debug('Параметры сканирования уязвимостей:', {
        userId,
        projectId,
        options,
      });
    }

    const project = await this.projectsService.findByIdForUser(
      userId,
      projectId,
    );

    // Очищаем старые данные анализа уязвимостей для этого проекта
    await this.cleanupOldAnalysisData(projectId, 'VULNERABILITY', null);

    // Создаем отчет о сканировании
    const report = await this.databaseService.analysisReport.create({
      data: {
        projectId,
        type: 'VULNERABILITY',
        status: 'PROCESSING',
        language: options.languages?.join(',') || 'all',
        result: {},
        progress: {
          currentStep: 'Starting vulnerability scan',
          percentage: 0,
          processedFiles: 0,
          totalFiles: 0,
        },
      },
    });

    this.logger.log(
      `Создан отчет сканирования уязвимостей ${report.id} для проекта ${projectId}`,
    );

    try {
      // Запускаем сканирование в фоне
      void this.performScan(report.id, project.extractedPath, options);

      const duration = Date.now() - startTime;
      this.logger.log(
        `Сканирование уязвимостей ${report.id} инициализировано за ${duration}ms`,
      );

      return report;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(
        `Ошибка при инициализации сканирования уязвимостей ${report.id} (${duration}ms):`,
        error,
      );

      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
      throw error;
    }
  }

  async scanProjectForReport(
    reportId: string,
    userId: string,
    projectId: string,
    options: VulnerabilityScanOptions = {},
  ): Promise<void> {
    const logLevel = getLogLevel();
    const startTime = Date.now();

    this.logger.log(`Начинаем сканирование уязвимостей для отчета ${reportId}`);

    if (logLevel === 'detailed') {
      this.logger.debug('Параметры сканирования уязвимостей для отчета:', {
        reportId,
        userId,
        projectId,
        options,
      });
    }

    const project = await this.projectsService.findByIdForUser(
      userId,
      projectId,
    );

    try {
      // Запускаем сканирование напрямую для существующего отчета
      await this.performScan(reportId, project.extractedPath, options);

      const duration = Date.now() - startTime;
      this.logger.log(
        `Сканирование уязвимостей для отчета ${reportId} инициализировано за ${duration}ms`,
      );
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(
        `Ошибка при инициализации сканирования уязвимостей для отчета ${reportId} (${duration}ms):`,
        error,
      );

      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
      throw error;
    }
  }

  async scanFile(
    userId: string,
    projectId: string,
    filePath: string,
  ): Promise<AnalysisReport> {
    const project = await this.projectsService.findByIdForUser(
      userId,
      projectId,
    );

    const report = await this.databaseService.analysisReport.create({
      data: {
        projectId,
        type: 'VULNERABILITY',
        status: 'PROCESSING',
        filePath,
        language: this.detectLanguageFromPath(filePath),
        result: {},
        progress: {
          currentStep: 'Scanning file',
          percentage: 0,
          processedFiles: 0,
          totalFiles: 1,
        },
      },
    });

    try {
      const fullPath = `${project.extractedPath}/${filePath}`;
      const results = await this.scanSingleFile(fullPath);

      await this.saveVulnerabilities(report.id, results);

      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'COMPLETED',
          result: {
            vulnerabilitiesFound: results.vulnerabilities.length,
            scanTime: results.scanTime,
          },
          progress: {
            currentStep: 'Completed',
            percentage: 100,
            processedFiles: 1,
            totalFiles: 1,
          },
        },
      });

      return report;
    } catch (error) {
      await this.databaseService.analysisReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
      throw error;
    }
  }

  async getVulnerabilities(
    userId: string,
    projectId: string,
    filters: {
      severity?: VulnSeverity;
      filePath?: string;
      type?: string;
    } = {},
  ): Promise<{ vulnerabilities: Vulnerability[]; stats: VulnerabilityStats }> {
    await this.projectsService.findByIdForUser(userId, projectId);

    const where: Prisma.VulnerabilityWhereInput = {
      report: {
        projectId,
        type: 'VULNERABILITY',
      },
    };

    if (filters.severity) {
      where.severity = filters.severity;
    }

    if (filters.filePath) {
      where.filePath = { contains: filters.filePath };
    }

    if (filters.type) {
      where.type = filters.type;
    }

    const vulnerabilities = await this.databaseService.vulnerability.findMany({
      where,
      orderBy: [{ severity: 'asc' }, { createdAt: 'desc' }],
    });

    const stats = this.calculateStats(vulnerabilities);

    return { vulnerabilities, stats };
  }

  private async performScan(
    reportId: string,
    projectPath: string,
    options: VulnerabilityScanOptions,
  ): Promise<void> {
    const logLevel = getLogLevel();
    const scanStartTime = Date.now();

    this.logger.log(`Начинаем выполнение сканирования уязвимостей ${reportId}`);

    if (logLevel === 'detailed') {
      this.logger.debug('Параметры сканирования:', {
        reportId,
        projectPath,
        options,
      });
    }

    try {
      const languages = options.languages || [
        'typescript',
        'javascript',
        'python',
        'go',
      ];
      const patterns = this.getPatternsForLanguages(languages);

      this.logger.log(
        `Сканируем языки: ${languages.join(', ')} с ${patterns.length} паттернами`,
      );

      const allResults: ScanResult[] = [];
      let processedFiles = 0;
      let totalFiles = 0;

      // Подсчитываем общее количество файлов
      for (const scanner of this.scanners) {
        if (
          languages.some((lang) => scanner.supportedLanguages.includes(lang))
        ) {
          const files = await this.findSourceFiles(projectPath, scanner);
          totalFiles += files.length;
          this.logger.log(
            `Сканер ${scanner.constructor.name} найдет ${files.length} файлов`,
          );
        }
      }

      this.logger.log(`Всего файлов для сканирования: ${totalFiles}`);

      await this.updateProgress(
        reportId,
        'Scanning files',
        0,
        processedFiles,
        totalFiles,
      );

      // Сканируем каждый язык
      for (const scanner of this.scanners) {
        if (
          languages.some((lang) => scanner.supportedLanguages.includes(lang))
        ) {
          // Проверяем отмену перед каждым сканером
          await this.checkCancellation(reportId);

          const scannerStartTime = Date.now();
          this.logger.log(
            `Запускаем сканер ${scanner.constructor.name} для отчета ${reportId}`,
          );

          const results = await scanner.scanProject(
            projectPath,
            patterns,
            options,
          );

          const scannerDuration = Date.now() - scannerStartTime;
          const vulnerabilitiesFound = results.reduce(
            (sum, r) => sum + r.vulnerabilities.length,
            0,
          );

          this.logger.log(
            `Сканер ${scanner.constructor.name} завершен за ${scannerDuration}ms: найдено ${vulnerabilitiesFound} уязвимостей в ${results.length} файлах`,
          );

          if (logLevel === 'detailed') {
            this.logger.debug(
              `Детали сканирования ${scanner.constructor.name}:`,
              {
                filesScanned: results.length,
                vulnerabilitiesFound,
                scanTime: scannerDuration,
                results: results.map((r) => ({
                  filePath: r.filePath,
                  vulnerabilities: r.vulnerabilities.length,
                  scanTime: r.scanTime,
                })),
              },
            );
          }

          allResults.push(...results);
          processedFiles += results.length;

          const percentage = Math.round((processedFiles / totalFiles) * 100);
          await this.updateProgress(
            reportId,
            `Scanning ${scanner.constructor.name}`,
            percentage,
            processedFiles,
            totalFiles,
          );
        }
      }

      // Сохраняем результаты
      this.logger.log(
        `Сохраняем результаты сканирования для отчета ${reportId}`,
      );
      await this.saveVulnerabilities(reportId, ...allResults);

      const totalVulnerabilities = allResults.reduce(
        (sum, r) => sum + r.vulnerabilities.length,
        0,
      );
      const totalScanTime = allResults.reduce((sum, r) => sum + r.scanTime, 0);

      this.logger.log(
        `Сканирование ${reportId} завершено: найдено ${totalVulnerabilities} уязвимостей в ${allResults.length} файлах`,
      );

      if (logLevel === 'detailed') {
        this.logger.debug('Статистика сканирования:', {
          reportId,
          totalFiles,
          processedFiles,
          totalVulnerabilities,
          totalScanTime,
          vulnerabilitiesByFile: allResults.map((r) => ({
            filePath: r.filePath,
            count: r.vulnerabilities.length,
          })),
        });
      }

      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          status: 'COMPLETED',
          result: {
            vulnerabilitiesFound: totalVulnerabilities,
            filesScanned: allResults.length,
            totalScanTime,
          },
          progress: {
            currentStep: 'Completed',
            percentage: 100,
            processedFiles,
            totalFiles,
          },
        },
      });

      const totalDuration = Date.now() - scanStartTime;
      this.logger.log(
        `Сканирование уязвимостей ${reportId} успешно завершено за ${totalDuration}ms`,
      );
    } catch (error) {
      const totalDuration = Date.now() - scanStartTime;

      // Если это ошибка отмены, не логируем как ошибку
      if (error instanceof AnalysisCancellationError) {
        this.logger.log(
          `Сканирование уязвимостей ${reportId} было отменено пользователем (${totalDuration}ms)`,
        );
        return; // Не обновляем статус, он уже установлен в CANCELLED
      }

      this.logger.error(
        `Ошибка при сканировании проекта ${reportId} (${totalDuration}ms):`,
        error,
      );

      if (logLevel === 'detailed') {
        this.logger.debug('Детали ошибки сканирования:', {
          reportId,
          projectPath,
          options,
          error:
            error instanceof Error
              ? {
                  name: error.name,
                  message: error.message,
                  stack: error.stack,
                }
              : String(error),
        });
      }

      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          status: 'FAILED',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      });
    }
  }

  private async scanSingleFile(filePath: string): Promise<ScanResult> {
    const language = this.detectLanguageFromPath(filePath);
    const patterns = getPatternsByLanguage(language);

    const scanner = this.scanners.find((s) =>
      s.supportedLanguages.includes(language),
    );
    if (!scanner) {
      throw new Error(`Нет сканера для языка ${language}`);
    }

    const { promises: fsp } = await import('node:fs');
    const content = await fsp.readFile(filePath, 'utf-8');

    return scanner.scanFile(filePath, content, patterns);
  }

  private async saveVulnerabilities(
    reportId: string,
    ...results: ScanResult[]
  ): Promise<void> {
    const vulnerabilities: any[] = [];

    for (const result of results) {
      for (const vuln of result.vulnerabilities) {
        vulnerabilities.push({
          reportId,
          severity: this.mapSeverity(vuln.message),
          type: this.extractVulnType(vuln.message),
          title: this.generateTitle(vuln.message),
          description: vuln.message,
          filePath: result.filePath,
          lineStart: vuln.lineStart,
          lineEnd: vuln.lineEnd,
          codeSnippet: vuln.codeSnippet,
          recommendation: vuln.recommendation,
          cwe: this.extractCWE(vuln.message),
        });
      }
    }

    if (vulnerabilities.length > 0) {
      await this.databaseService.vulnerability.createMany({
        data: vulnerabilities,
      });
    }
  }

  private async updateProgress(
    reportId: string,
    currentStep: string,
    percentage: number,
    processedFiles: number,
    totalFiles: number,
  ): Promise<void> {
    try {
      // Проверяем существование отчета перед обновлением
      const existingReport = await this.databaseService.analysisReport.findUnique({
        where: { id: reportId },
        select: { id: true },
      });

      if (!existingReport) {
        this.logger.warn(`Попытка обновить несуществующий отчет ${reportId}`);
        return;
      }

      await this.databaseService.analysisReport.update({
        where: { id: reportId },
        data: {
          progress: {
            currentStep,
            percentage,
            processedFiles,
            totalFiles,
          },
        },
      });
    } catch (error) {
      this.logger.error(`Ошибка при обновлении прогресса отчета ${reportId}:`, error);
      // Не прерываем выполнение анализа из-за ошибки обновления прогресса
    }
  }

  private async checkCancellation(reportId: string): Promise<void> {
    const report = await this.databaseService.analysisReport.findUnique({
      where: { id: reportId },
      select: { status: true },
    });

    if (report?.status === 'CANCELLED') {
      throw new AnalysisCancellationError(reportId);
    }
  }

  private async cleanupOldAnalysisData(projectId: string, analysisType: string, excludeReportId?: string | null): Promise<void> {
    const logLevel = getLogLevel();
    const cleanupStartTime = Date.now();

    this.logger.log(`Очищаем старые данные анализа типа ${analysisType} для проекта ${projectId}${excludeReportId ? ` (исключая отчет ${excludeReportId})` : ''}`);

    try {
      // Получаем все старые отчеты анализа того же типа для проекта
      const whereClause: any = { 
        projectId,
        type: analysisType
      };
      if (excludeReportId) {
        whereClause.id = { not: excludeReportId };
      }

      const oldReports = await this.databaseService.analysisReport.findMany({
        where: whereClause,
        select: { id: true },
      });

      if (oldReports.length === 0) {
        this.logger.log(`Нет старых данных анализа типа ${analysisType} для очистки в проекте ${projectId}`);
        return;
      }

      const reportIds = oldReports.map(report => report.id);

      if (logLevel === 'detailed') {
        this.logger.debug('Очищаем данные для отчетов:', {
          projectId,
          analysisType,
          reportIds,
          count: reportIds.length,
        });
      }

      // Удаляем связанные данные в правильном порядке (из-за foreign key constraints)
      
      // 1. Удаляем уязвимости
      const deletedVulnerabilities = await this.databaseService.vulnerability.deleteMany({
        where: { reportId: { in: reportIds } },
      });

      // 2. Удаляем объяснения кода
      const deletedExplanations = await this.databaseService.codeExplanation.deleteMany({
        where: { reportId: { in: reportIds } },
      });

      // 3. Удаляем отчеты анализа
      const deletedReports = await this.databaseService.analysisReport.deleteMany({
        where: { id: { in: reportIds } },
      });

      const cleanupDuration = Date.now() - cleanupStartTime;
      this.logger.log(`Очистка данных анализа типа ${analysisType} для проекта ${projectId} завершена за ${cleanupDuration}ms: удалено ${deletedReports.count} отчетов, ${deletedVulnerabilities.count} уязвимостей, ${deletedExplanations.count} объяснений`);

      if (logLevel === 'detailed') {
        this.logger.debug('Статистика очистки:', {
          projectId,
          analysisType,
          deletedReports: deletedReports.count,
          deletedVulnerabilities: deletedVulnerabilities.count,
          deletedExplanations: deletedExplanations.count,
          cleanupDuration,
        });
      }

    } catch (error) {
      const cleanupDuration = Date.now() - cleanupStartTime;
      this.logger.error(`Ошибка при очистке старых данных анализа для проекта ${projectId} (${cleanupDuration}ms):`, error);
      
      if (logLevel === 'detailed') {
        this.logger.debug('Детали ошибки очистки:', {
          projectId,
          error: error instanceof Error ? {
            name: error.name,
            message: error.message,
            stack: error.stack,
          } : String(error),
        });
      }
      
      // Не прерываем выполнение анализа из-за ошибки очистки
      this.logger.warn(`Продолжаем анализ несмотря на ошибку очистки данных для проекта ${projectId}`);
    }
  }

  private getPatternsForLanguages(languages: string[]) {
    const patterns = new Set<VulnerabilityPattern>();
    for (const lang of languages) {
      getPatternsByLanguage(lang).forEach((pattern) => patterns.add(pattern));
    }
    return Array.from(patterns);
  }

  private async findSourceFiles(
    projectPath: string,
    scanner: BaseScanner,
  ): Promise<string[]> {
    // Упрощенная реализация - в реальности нужно использовать методы сканера
    const { promises: fsp } = await import('node:fs');
    const files: string[] = [];

    const walk = async (dir: string) => {
      const entries = await fsp.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = `${dir}/${entry.name}`;
        if (entry.isDirectory() && !this.isIgnoredDirectory(entry.name)) {
          await walk(fullPath);
        } else if (
          entry.isFile() &&
          scanner.supportedLanguages.includes(
            this.detectLanguageFromPath(fullPath),
          )
        ) {
          files.push(fullPath);
        }
      }
    };

    await walk(projectPath);
    return files;
  }

  private isIgnoredDirectory(dirName: string): boolean {
    const ignoredDirs = [
      'node_modules',
      '.git',
      'dist',
      'build',
      '.next',
      '.turbo',
      '__pycache__',
      '.pytest_cache',
      'venv',
      'env',
    ];
    return ignoredDirs.includes(dirName) || dirName.startsWith('.');
  }

  private detectLanguageFromPath(filePath: string): string {
    const ext = filePath.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'ts':
      case 'tsx':
        return 'typescript';
      case 'js':
      case 'jsx':
        return 'javascript';
      case 'py':
        return 'python';
      case 'java':
        return 'java';
      case 'go':
        return 'go';
      default:
        return 'unknown';
    }
  }

  private mapSeverity(message: string): VulnSeverity {
    if (message.includes('CRITICAL') || message.includes('Critical'))
      return VulnSeverity.CRITICAL;
    if (message.includes('HIGH') || message.includes('High'))
      return VulnSeverity.HIGH;
    if (message.includes('MEDIUM') || message.includes('Medium'))
      return VulnSeverity.MEDIUM;
    if (message.includes('LOW') || message.includes('Low'))
      return VulnSeverity.LOW;
    return VulnSeverity.INFO;
  }

  private extractVulnType(message: string): string {
    if (message.includes('SQL')) return 'SQL_INJECTION';
    if (message.includes('XSS')) return 'XSS';
    if (message.includes('Path')) return 'PATH_TRAVERSAL';
    if (message.includes('secret') || message.includes('password'))
      return 'HARDCODED_SECRETS';
    if (
      message.includes('crypto') ||
      message.includes('MD5') ||
      message.includes('SHA-1')
    )
      return 'INSECURE_CRYPTO';
    return 'UNKNOWN';
  }

  private generateTitle(message: string): string {
    return message.split('.')[0] || 'Security vulnerability detected';
  }

  private extractCWE(message: string): string | undefined {
    const cweMatch = message.match(/CWE-\d+/);
    return cweMatch ? cweMatch[0] : undefined;
  }

  private calculateStats(vulnerabilities: Vulnerability[]): VulnerabilityStats {
    const stats: VulnerabilityStats = {
      total: vulnerabilities.length,
      bySeverity: {
        CRITICAL: 0,
        HIGH: 0,
        MEDIUM: 0,
        LOW: 0,
        INFO: 0,
      },
      byType: {},
      byFile: {},
    };

    for (const vuln of vulnerabilities) {
      stats.bySeverity[vuln.severity]++;
      stats.byType[vuln.type] = (stats.byType[vuln.type] || 0) + 1;
      stats.byFile[vuln.filePath] = (stats.byFile[vuln.filePath] || 0) + 1;
    }

    return stats;
  }
}
